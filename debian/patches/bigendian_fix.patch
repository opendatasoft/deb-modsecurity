Description: Fix inet addr handling on 64 bit big endian systems
 On bigendian systems the IP address related tests had failed. This
 patch made for the Debian, and merged to upstream.
Author: Ervin Hegedus <airween@gmail.com>

---
Origin: upstream, https://github.com/SpiderLabs/ModSecurity/commit/a9e9da8694cc1328f0b262272ebb2b5e55b3d97d
Bug: https://github.com/SpiderLabs/ModSecurity/issues/1980
Last-Update: 2018-12-11

--- modsecurity-3.0.3.orig/src/utils/msc_tree.cc
+++ modsecurity-3.0.3/src/utils/msc_tree.cc
@@ -832,7 +832,7 @@ TreeNode *TreeAddIP(const char *buffer,
     switch(type)    {
 
         case IPV4_TREE:
-            memset(&addr4, 0, sizeof(addr4));
+            memset(&(addr4.s_addr), 0, sizeof(addr4.s_addr));
             memset(ip_strv4, 0x0, NETMASK_32);
 
             strncpy(ip_strv4, buffer, sizeof(ip_strv4));
@@ -857,18 +857,17 @@ TreeNode *TreeAddIP(const char *buffer,
                 ip_strv4[pos] = '\0';
             }
 
-            ret = inet_pton(AF_INET, ip_strv4, &addr4);
+            ret = inet_pton(AF_INET, ip_strv4, &(addr4.s_addr));
 
             if (ret <= 0) {
                 return NULL;
             }
-            ip = addr4.s_addr;
 
             tree->count++;
-            return CPTAddElement((unsigned char *)&ip, NETMASK_32, tree, netmask_v4);
+            return CPTAddElement((unsigned char *)&(addr4.s_addr), NETMASK_32, tree, netmask_v4);
 
         case IPV6_TREE:
-            memset(&addr6, 0, sizeof(addr6));
+            memset(&(addr6.s6_addr), 0, sizeof(addr6.s6_addr));
             memset(ip_strv6, 0x0, NETMASK_128);
 
             strncpy(ip_strv6, buffer, sizeof(ip_strv6));
@@ -895,7 +894,7 @@ TreeNode *TreeAddIP(const char *buffer,
                 ip_strv6[pos] = '\0';
             }
 
-            ret = inet_pton(AF_INET6, ip_strv6, &addr6);
+            ret = inet_pton(AF_INET6, ip_strv6, &(addr6.s6_addr));
 
             if (ret <= 0)
             {
@@ -904,7 +903,7 @@ TreeNode *TreeAddIP(const char *buffer,
 
             tree->count++;
 
-            return CPTAddElement((unsigned char *)&addr6.s6_addr, NETMASK_128, tree, netmask_v6);
+            return CPTAddElement((unsigned char *)&(addr6.s6_addr), NETMASK_128, tree, netmask_v6);
         default:
             return NULL;
     }
@@ -933,25 +932,25 @@ int tree_contains_ip(TreeRoot *rtree,
     }
 
     if (strchr(value, ':') == NULL) {
-        if (inet_pton(AF_INET, value, &in) <= 0) {
+        if (inet_pton(AF_INET, value, &(in.s_addr)) <= 0) {
             //*error_msg = apr_psprintf(mp, "IPmatch: bad IPv4 " \
             //    "specification \"%s\".", value);
             return -1;
         }
 
-        if (CPTIpMatch((unsigned char *)&in.s_addr, rtree->ipv4_tree,
+        if (CPTIpMatch((unsigned char *)&(in.s_addr), rtree->ipv4_tree,
             IPV4_TREE) != NULL) {
             return 1;
         }
     }
     else {
-        if (inet_pton(AF_INET6, value, &in6) <= 0) {
+        if (inet_pton(AF_INET6, value, &(in6.s6_addr)) <= 0) {
             //*error_msg = apr_psprintf(mp, "IPmatch: bad IPv6 " \
              //   "specification \"%s\".", value);
             return -1;
         }
 
-        if (CPTIpMatch((unsigned char *)&in6.s6_addr, rtree->ipv6_tree,
+        if (CPTIpMatch((unsigned char *)&(in6.s6_addr), rtree->ipv6_tree,
             IPV6_TREE) != NULL) {
             return 1;
         }
